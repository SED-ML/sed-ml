\section{General data types, attributes and classes}
In this section concepts used repeatedly throughout the SED-ML specification are introduced. This includes  \hyperref[sec:dataTypes]{primitive data types}, classes (\SedBase, \Notes, \hyperref[class:notes]{Annotation}, \Parameter, \Variable), \hyperref[sec:generalAttributes]{attributes}, and \hyperref[sec:reference]{reference relations}.

The main \hyperref[sec:components]{SED-ML components} based on these general data types, attributes and classes are described in Section~\ref{sec:components}.

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% PRIMITIVE DATA TYPES
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{Primitive data types}
\label{sec:dataTypes}
Primitive data types comprise the set of data types used in SED-ML classes. Most primitive types in SED-ML are taken from the data types defined in XML Schema 1.0, including \element{string}, \element{boolean}, \element{int}, \element{positiveInteger}, \element{double} and \element{XML}. 

A few additional primitive types are defined by SED-ML itself: \hyperref[type:id]{\element{ID}}, \SId, \SIdRef, \hyperref[type:target]{\element{TargetType}}, \hyperref[type:xpath]{\element{XPath}}, \hyperref[type:mathml]{\element{MathML}}, \hyperref[type:anyURI]{\element{anyURI}}, \hyperref[type:numlsid]{\element{NuMLSId}}, and \hyperref[type:numlsidref]{\element{NuMLSIdRef}}.

\subsubsection[\element{ID}]{Type \element{ID}}
\label{type:id}
The XML Schema 1.0 type \concept{\element{ID}} is identical to the XML 1.0 type \element{ID}. The literal representation of this type consists of strings of characters restricted as summarized in Figure~\vref{fig:id}. For a detailed description see the SBML specification on type \concept{\element{ID}} \citep{HBH+10}.

\begin{figure}[hbt]
  \ttfamily
  \small
  \centering
  \begin{tabular}{lll}
    NameChar & ::= & letter | digit | '.' | '-' | ' ' | ':' | CombiningChar | Extender\\
    ID    & ::= & ( letter | ' ' | ':' ) NameChar*\\
  \end{tabular}
  \vspace*{-1ex}
  \caption{The definition of the type \code{ID}. The characters ( and ) are used for grouping, the character * indicates "zero or more times", and the character | indicates "or". Please consult the XML 1.0 specification for the complete definitions of letter, digit, CombiningChar, and Extender.}
  \label{fig:id}
\end{figure}

\subsubsection[\element{SId}]{Type \element{SId}}
\label{type:sid}
The type \concept{\element{SId}} is the type of the id attribute found on the majority of SED-ML components. \concept{\element{SId}} is a data type derived from \element{string}, but with restrictions about the characters permitted and the sequences in which those characters may appear. The definition is shown in Figure~\vref{fig:sid}. For a detailed description see the SBML specification on type \concept{\element{SId}} \citep{HBH+10}.

\begin{figure}[hbt]
  \ttfamily
  \small
  \centering
  \begin{tabular}{lll}
    letter & ::= & 'a'..'z','A'..'Z'\\
    digit  & ::= & '0'..'9'\\
    idChar & ::= & letter | digit | `\_'\\
    SId    & ::= & ( letter | '\_' ) idChar*\\
  \end{tabular}
  \vspace*{-1ex}
  \caption{The definition of the type \code{SId}}
  \label{fig:sid}
\end{figure}

\subsubsection[\SIdRef]{Type \SIdRef}
\label{type:sidref}
Type \concept{SIdRef} is used for all attributes that refer to identifiers of type \SId in a model. This type is derived from \SId, but with the restriction that the value of an attribute having type \concept{SIdRef} must equal the value of some \SId attribute. In other words, a \concept{SIdRef} value must be an existing identifier.

As with \SId, the equality of \concept{SIdRef} values is determined by exact character sequence match; i.e., comparisons of these identifiers must be performed in a case-sensitive manner.

\begin{blockChanged}
\subsubsection[\element{TargetType}]{Type \element{TargetType}}
\label{type:target}
Type \concept{\element{TargetType}} is used to identify elements of a model.  This type is derived from type \element{string}, and it is up to the target modeling language to define what form makes sense to uniquely identify a particular element of that model.  For XML-based languages, using an \element{XPath} is required when referencing the raw XML of the model in a \ChangeXML, \AddXML, or \RemoveXML, but other schemes may be used when referencing more abstract concepts implied by the model.
\end{blockChanged}

\subsubsection[\element{XPath}]{Type \element{XPath}}
\label{type:xpath}
Type \concept{\element{XPath}} is \changed{derived from type \element{TargetType} and is} used to identify nodes and attributes within an XML representation. \concept{\element{XPath}} in SED-ML is an \hyperref[sec:xpath]{XPath} version 1 expression which can be used to unambiguously identify an element or attribute in an XML file. The concept of \hyperref[sec:xpath]{XPath} is described in Section~\ref{sec:xpath}.  Note that \concept{\element{XPath}} may be used by some model languages to imply more abstract concepts implied by the model, such as pointing to an XML element to mean `the current value of this element in the changed model state'.

\begin{blockChanged}
\subsubsection[\element{URN}]{Type \element{URN}}
\label{type:urn}
A \element{URN} is a colon-separated string that reference an external variable, but does not imply accessibility of that variable.  The notion of implicit variables is explained in Section~\ref{sec:implicitVariable}.
\end{blockChanged}

\subsubsection[\element{MathML}]{Type \element{MathML}}
\label{type:mathml}
Type \concept{\element{MathML}} is used to describe mathematical expression in \hyperref[sec:mathML]{MathML}. The concept of \hyperref[sec:mathML]{MathML} and the allowed subset of \hyperref[sec:mathML]{MathML} on a \concept{\element{MathML}} attribute is described in Section~\ref{sec:mathML}.

\subsubsection[\element{anyURI}]{Type \element{anyURI}}
\label{type:anyURI}
Type \concept{\code{anyURI}} is used to reference model and data files, specify the language of models, the format of data files, for referencing implicit model variables, and in annotations. For a description of the uses of \concept{\code{anyURI}} see Section~\ref{sec:uriScheme}.

\subsubsection[\element{NuMLSId}]{Type \element{NuMLSId}}
\label{type:numlsid}
The type \concept{\element{NuMLSId}} is the type of the \element{id} attribute found on NuML components. \concept{\element{NuMLSId}} is a data type derived from \SId, with the same restrictions about the characters permitted and the sequences in which those characters may appear as \hyperref[type:sid]{SId}. The concept of NuML is described in Section~\ref{sec:numl}.

\subsubsection[\element{NuMLSIdRef}]{Type \element{NuMLSIdRef}}
\label{type:numlsidref}
Type \concept{\element{NuMLSIdRef}} is used for all attributes that refer to identifiers of type \hyperref[type:numlsid]{\element{NuMLSId}} in a model. This type is derived from \hyperref[type:numlsid]{\element{NuMLSId}}, but with the restriction that the value of an attribute having type \concept{\element{NuMLSIdRef}} must equal the value of some \hyperref[type:numlsid]{\element{NuMLSId}} attribute. In other words, a \concept{\element{NuMLSIdRef}} value must be an existing NuML identifier.

As with \hyperref[type:numlsid]{\element{NuMLSId}}, the equality of \concept{\element{NuMLSIdRef}} values is determined by exact character sequence match; i.e., comparisons of these identifiers must be performed in a case-sensitive manner.

\begin{blockChanged}
\subsubsection[\element{AxisType}]{Type \element{AxisType}}
\label{type:axisType}

The \element{AxisType} primitive data type is used in the definition of the \Axis class.  \element{AxisType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{linear}, and \val{log10}.  Attributes of type \element{AxisType} cannot take on any other values.  The meaning of these values is discussed in the context of the \Axis class's definition in \ref{class:axis}.

\subsubsection[\element{CurveType}]{Type \element{CurveType}}
\label{type:curveType}

The \element{CurveType} primitive data type is used in the definition of the \Curve class.  \element{CurveType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{points}, \val{bar}, \val{barStacked}, \val{horizontalBar}, and \val{horizontalBarStacked}.  Attributes of type \element{CurveType} cannot take on any other values.  The meaning of these values is discussed in the context of the \Curve class's definition in \ref{class:curve}.

\subsubsection[\element{SurfaceType}]{Type \element{SurfaceType}}
\label{type:surfaceType}

The \element{SurfaceType} primitive data type is used in the definition of the \Surface class.  \element{SurfaceType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{parametricCurve}, \val{surfaceMesh}, \val{surfaceContour}, \val{contour}, \val{heatMap}, \val{stackedCurves}, and \val{bar}.  Attributes of type \element{SurfaceType} cannot take on any other values.  The meaning of these values is discussed in the context of the \Surface class's definition in \ref{class:surface}.

\subsubsection[\element{LineType}]{Type \element{LineType}}
\label{type:lineType}

The \element{LineType} primitive data type is used in the definition of the \Line class.  \element{LineType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{none}, \val{solid}, \val{dash}, \val{dot}, \val{dashDot}, and \val{dashDotDot}.  Attributes of type \element{LineType} cannot take on any other values.  The meaning of these values is discussed in the context of the \Line class's definition in \ref{class:line}.

\subsubsection[\element{SedColor}]{Type \element{SedColor}}
\label{type:sedColor}

The \element{SedColor} primitive data type is used in the definition of various children of the \Style class.  \element{SedColor} is derived from type \element{string} and its values are allowed to be a six-character RGB hex value (where the alpha is assumed to be 100\%), or an eight-character RGBA hex value.  For example, 808000FF would be red and green 50.2\%, blue 0\%, and alpha 100\%, i.e. a brown.  Attributes of type \element{SedColor} cannot take on any other values.

\subsubsection[\element{MarkerType}]{Type \element{MarkerType}}
\label{type:markerType}

The \element{MarkerType} primitive data type is used in the definition of the \Marker class.  \element{MarkerType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{none}, \val{square}, \val{circle}, \val{diamond}, \val{xCross}, \val{plus}, \val{star}, \val{triangleUp}, \val{triangleDown}, \val{triangleLeft}, \val{triangleRight}, \val{hDash}, and \val{vDash}.  Attributes of type \element{MarkerType} cannot take on any other values.  The meaning of these values is discussed in the context of the \Marker class's definition in \ref{class:marker}.


\subsubsection[\element{MappingType}]{Type \element{MappingType}}
\label{type:mappingType}

The \element{MappingType} primitive data type is used in the definition of the \FitMapping class.  \element{MappingType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{time}, \val{experimentalCondition} and \val{observable}.  Attributes of type \element{MappingType} cannot take on any other values.  The meaning of these values is discussed in the context of the \FitMapping class's definition in \ref{class:fitMapping}.


\subsubsection[\element{ExperimentType}]{Type \element{ExperimentType}}
\label{type:experimentType}

The \element{ExperimentType} primitive data type is used in the definition of the \FitExperiment class.  \element{ExperimentType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{steadyState} and \val{timeCourse}.  Attributes of type \element{ExperimentType} cannot take on any other values.  The meaning of these values is discussed in the context of the \FitExperiment class's definition in \ref{class:fitExperiment}.


\subsubsection[\element{ScaleType}]{Type \element{ScaleType}}
\label{type:scaleType}

The \element{ScaleType} primitive data type is used in the definition of the \Bounds class.  \element{ScaleType} is derived from type \element{string} and its values are restricted to being one of the following possibilities: \val{lin}, \val{log}, and \val{log10}.  Attributes of type \element{ScaleType} cannot take on any other values.  The meaning of these values is discussed in the context of the \Bounds class's definition in \ref{class:bounds}.


\end{blockChanged}


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% SEDBASE
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{SEDBase}}
\label{class:sedBase}
\concept{SEDBase} is the base class of all SED-ML classes (\fig{sedBase}). The \concept{SEDBase} class has the optional attribute \hyperref[sec:metaid]{\element{metaid}}, and the two optional subelements \hyperref[sec:notesElement]{\element{notes}} and \hyperref[sec:annotationElement]{\element{annotation}}. 

\concept{SEDBase} provides means to attach additional information on all other classes. That information can be specified by human readable \Notes or custom \Annotation.

\begin{blockChanged}
\sedfig[width=0.75\textwidth]{images/uml/sedBase}{The \SEDBase, \Notes, and \Annotation classes}{fig:sedBase}

% ~~~ ID ~~~
\paragraph*{\element{id}}
\label{sec:id}
The \element{id} attribute is an optional attribute on the \SEDBase class.  The \element{id} attribute value on an object serves as its \emph{identifier}.  The data type of \element{id} on \SEDBase is \element{SId} (Section~\ref{type:sid}).  Every \element{SId} attribute value in a \SedDocument must be unique.  Whenever a SED-ML element references another SED-ML element, it uses this identifier to do so.

Although \element{id} is optional on \SEDBase, object classes derived from \SEDBase may stipulate that \element{id} is a required attribute for those classes.

In lower Level/Version combinations of SED-ML, the attributes \element{id} and \element{name} are defined on individual object subclasses.  The movement of these attributes to \SEDBase in this version has no practical effect on these classes.

An example for an \concept{\element{id}} is given in Listing~\ref{lst:id}. In the example the model has the \concept{\element{id}} \code{m00001}.

\begin{myXmlLst}{SED-ML \element{id} definition, e.g., for a model}{lst:id}
<model id="m00001" language="urn:sedml:language:sbml"
        source="https://www.ebi.ac.uk/biomodels/model/download/BIOMD0000000012?filename=BIOMD0000000012_url.xml">
	[MODEL DEFINITION]
</model>
\end{myXmlLst}


% ~~~ NAME ~~~
\paragraph*{\element{name}}
\label{sec:name}
The attribute \element{name} is an optional attribute on \SEDBase of type \element{string}.  
In contrast to the \element{id} attribute, the \element{name} attribute
is not intended to be used for cross-referencing
purposes within a model.  Its purpose instead is to provide a
human-readable label for a component.  The data type of 
\element{name} is the type \element{string} defined in XML
Schema~\citep{biron:2000,thompson:2000}.  SED-ML imposes no restrictions
as to the content of \element{name} attributes beyond those restrictions
defined by the \element{string} type in XML Schema.
In addition, there are no restrictions on the uniqueness
of \element{name} values in a \SedDocument.

Listing \ref{lst:name} extends the model definition in \lst{id} by a model \concept{\element{name}}.

\begin{myXmlLst}{SED-ML \element{name} definition, e.g., for a model}{lst:name}
<model id="m00001" name="Circadian oscillator" language="urn:sedml:language:sbml"
        source="https://www.ebi.ac.uk/biomodels/model/download/BIOMD0000000012?filename=BIOMD0000000012_url.xml">
	[MODEL DEFINITION]
</model>
\end{myXmlLst}
\end{blockChanged}



% ~~~ META ID ~~~
\paragraph*{\element{metaid}}
\label{sec:metaid}
The main purpose of the \concept{\element{metaid}} attribute of data type \code{\hyperref[type:id]{ID}} is to attach semantic annotations in form of the \Annotation class to SED-ML elements. The \concept{\element{metaid}} attribute is globally unique throughout the SED-ML document, i.e., the \concept{\element{metaid}} must be unambiguous throughout a whole SED-ML document. As such it identifies the constituent it is related to.

In order to set either \Notes or \Annotation on a SED-ML class the \concept{\element{metaid}} is required.

\paragraph*{\element{notes}}
\label{sec:notesElement}
The optional \concept{\element{notes}} element stores \Notes on \SedBase.

\paragraph*{\element{annotation}}
\label{sec:annotationElement}
The optional \concept{\element{annotation}} element stores \Annotation on \SedBase.

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% NOTES
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{Notes}}
\label{class:notes}
A \concept{Notes} is considered a human-readable description of the element it is assigned to. Instances of the \concept{Notes} class may contain any valid XHTML \citep{P+02}. The namespace URL for \code{XHTML} content inside the \Notes class is \url{http://www.w3.org/1999/xhtml}, which may be declared either in the \SedML element, or directly in the top level XHTML elements contained within the \hyperref[sec:notesElement]{\code{notes}} element. For details on of how to set the namespace and examples see the SBML specification \citep{HBH+10}.

\tabtext{notes}{Notes}

\begin{table}[ht]
\center
\begin{tabular}{ll}
\toprule
\textbf{\attribute} & \textbf{\desc}\\
\midrule
xmlns:string & \refpage{sec:xmlns} \\
 {``http://www.w3.org/1999/xhtml" } & \\
\midrule
\textbf{\subelements} & \textbf{ }\\
\midrule
\emph{well-formed content permitted in XHTML} & \\
\bottomrule
\end{tabular}
\caption{\tabcap{Notes}}
\label{tab:notes}
\end{table}

\concept{Notes} does not have any further sub-elements defined in SED-ML, nor attributes associated with it.

\lsttext{notes}{notes}

\begin{myXmlLst}{The \element{notes} element}{lst:notes}
<sedML [..]>
	<notes>
  		<p xmlns="http://www.w3.org/1999/xhtml">The enclosed simulation description shows the oscillating behaviour of the Repressilator model using deterministic and stochastic simulators.</p>
	</notes>
</sedML>
\end{myXmlLst}

In this example, the namespace declaration is inside the \element{notes} element and the note is related to the \element{sedML} root element of the SED-ML file. A note may, however, occur inside \emph{any} SED-ML XML element, except \code{note} itself and \Annotation.


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% ANNOTATION
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{Annotation}}
\label{class:annotation}

An \concept{Annotation} is considered a computer-processable piece of information. Annotations may contain any valid XML content. For further guidelines on how to use annotations see the SBML specification \citep{HBH+10}. The style of annotations in SED-ML is briefly described in Section~\ref{sec:annotations}.

\lsttext{annotation}{annotation} In the example, a \hyperref[class:model]{\element{model}} element is annotated with a reference to the original publication. The \element{model} contains an \concept{\element{annotation}} that uses the model-qualifier \element{isDescribedBy} to link to the external resource \element{http://identifiers.org/pubmed/10415827}. In natural language the annotation content could be interpreted as ``The model is described by the published article available from pubmed under the identifier 10415827''.

\begin{myXmlLst}{The annotation element}{lst:annotation}
<sedML>
	[..]
	<model id="model1" metaid="_001" language="urn:sedml:language:cellml" source="goldbeter1999a.cellml" >
		<annotation>
    		<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:bqmodel="http://biomodels.net/model-qualifiers/">
				<rdf:Description rdf:about="#_001">
				<bqmodel:isDescribedBy>
				<rdf:Bag>
					<rdf:li rdf:resource="http://identifiers.org/pubmed/10415827"/>
				</rdf:Bag>
				</bqmodel:isDescribedBy>
    			</rdf:Description>
			</rdf:RDF>
		</annotation>
	</model>
	[..]
</sedML>
\end{myXmlLst}


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% PARAMETER
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{Parameter}}
\label{class:parameter}
The \concept{Parameter} class (\fig{parameter}) is used to create named parameters with a constant value.
The \concept{Parameter} class introduces the required \changed{attribute \hyperref[sec:value]{\element{value}} of type \element{double}, and inherits other attributes and children from \SEDBase, with the exception that the attribute \element{id} is required instead of optional.  The \element{id} takes on the value of the \element{value} in the context of the \Math of the parent \Calculation.  Its \element{id} may not be used in a \Calculation that is not its parent, but it must nevertheless be globally unique.}

\sedfig[width=0.35\textwidth]{images/uml/parameter}{The \Parameter class}{fig:parameter}

A \Parameter can be used wherever a mathematical expression to compute a value is defined, e.g., in \ComputeChange, \FunctionalRange or \DataGenerator. The \Parameter definitions are local to the particular class defining them. By using \concept{Parameters} rather than including numbers directly within a mathematical expression is that \hyperref[class:notes]{notes} and \hyperref[class:annotation]{annotations} can be associated with them.

Every \Parameter is defined inside a \ListOfParameters.  The element is optional and may contain zero to many parameters.

\lsttext{parameter}{parameter}
In the example a \concept{parameter} \code{p1} with the value \code{40} is defined. 
\begin{myXmlLst}{The definition of a parameter in SED-ML}{lst:parameter}
<listOfParameters>
	<parameter id="p1" name="KM" value="40" />
</listOfParameters>
\end{myXmlLst}


% ~~~ VALUE ~~
\paragraph*{\element{value}}
\label{sec:value}
The \concept{\element{value}} attribute of data type \code{double} is required for each \Parameter. Each \Parameter has exactly one fixed \concept{\element{value}}.

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% VARIABLE
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{Variable}}
\label{class:variable}
A \Variable (\fig{variable}) is a reference to an already existing entity, either explicitly created in the \SedDocument, or to an implicitly defined symbol.  The \Variable class inherits the attributes and children of \SEDBase, changing the attribute \element{id} to be required, and adds the context dependent attributes \hyperref[sec:target]{\element{target}}, \hyperref[sec:symbol]{\element{symbol}}, \hyperref[sec:taskReferenceAttribute]{\element{taskReference}}, and \hyperref[sec:modelReferenceAttribute]{\element{modelReference}}. It also may have any number of \AppliedDimension children, as members of its \ListOfAppliedDimensions optional child.

\sedfig[width=1.0\textwidth]{images/uml/variable}{The \Variable, \DependentVariable, \ListOfAppliedDimensions, and \AppliedDimension classes}{fig:variable}

If the variable is defined through a reference to a model constituent, such as an SBML species, or to an entity within the SED-ML file itself, then the reference is specified using the \hyperref[sec:target]{\element{target}} attribute. If the variable is defined through a reference to a \hyperref[sec:implicitVariable]{Symbol}, rather than one explicitly appearing in the model, then the \hyperref[sec:symbol]{\element{symbol}} attribute is used. 

\begin{itemize}
	\item A \Variable is always placed inside a \hyperref[class:listOfVariables]{listOfVariables}.  \changed{If it is the base class, its XML name will be \val{variable}; if it is the derived \DependentVariable class, its XML name will be \val{dependentVariable}.}
	\item \changed{The \hyperref[sec:symbol]{\element{symbol}} and \hyperref[sec:target]{\element{target}} attributes (plus the \element{term}, \element{symbol2}, and \element{target2} attributes of a \DependentVariable) must collectively define exactly one element with mathematical meaning.}
	\item A \Variable element must contain a \hyperref[sec:taskReference]{taskReference} if it occurs inside a \hyperref[class:listOfVariables]{\element{listOfVariables}} inside a \hyperref[class:dataGenerator]{dataGenerator} element. The only exception is if the \Variable references a \hyperref[class:dataSource]{DataSource}, in which case no \hyperref[sec:taskReference]{taskReference} is required.
	\item A \Variable element must contain a \hyperref[sec:modelReference]{modelReference} if it occurs inside a \hyperref[class:listOfVariables]{\element{listOfVariables}} inside a \hyperref[class:computeChange]{computeChange} element.  \changed{It must also define the \element{modelReference} if its \element{taskReference} points to a \RepeatedTask that contains references to multiple models.}
	\item A \Variable element appearing within a \hyperref[class:functionalRange]{functionalRange} or \hyperref[class:setValue]{setValue} element must contain a \hyperref[sec:modelReference]{modelReference} if and only if it references a model variable.
\end{itemize}

\lsttext{variable}{variable}
In the example a variable \code{v1} is defined to compute a change on a model constituent (referenced by the \hyperref[sec:target]{\element{target}} attribute on \hyperref[class:computeChange]{\element{computeChange}}). The value of \code{v1} corresponds to the value of the targeted model constituent referenced by the \code{target} attribute. The second variable \code{v2} is used inside a \hyperref[class:dataGenerator]{\element{dataGenerator}}. As the variable is \concept{time} as used in \code{task1}, the \hyperref[sec:symbol]{\element{symbol}} attribute is used to refer to the SED-ML URI for time.

\begin{myXmlLst}{SED-ML \code{variable} definitions inside the \code{computeChange} element and inside the \code{dataGenerator} element}{lst:variable}
<sedML>
	<listOfModels>
		<model [..]>
			<listOfChanges>
				<computeChange target="TARGET ELEMENT OR ATTRIBUTE">
				<listOfVariables>
				   <variable id="v1" name="maximum velocity" target="\changed{Path} TO MODEL ELEMENT/ATTRIBUTE" />
				   [FURTHER VARIABLE DEFINITIONS]
				</listOfVariables>
				[..]
				</computeChange>
			</listOfChanges>
			[..]
		</model>
		[..]
	</listOfModels>
	<listOfDataGenerators>
		<dataGenerator [..]>
			<listOfVariables>
				<variable id="v2" name="time" taskReference="task1" symbol="KISAO:0000832" />
				[FURTHER VARIABLE DEFINITIONS]
			</listOfVariables>
		</dataGenerator>
	</listOfDataGenerators>
	[..]
</sedML>
\end{myXmlLst}


% ~~~ TARGET ~~~
\paragraph*{\element{target}}
\label{sec:target}
An instance of \Variable can refer to a model constituent inside a particular \hyperref[class:model]{model} through \changed{the address stored in the \concept{\element{target}} attribute, such as an \code{\hyperref[type:xpath]{XPath}} expression}. 

Note that while it is possible to write \changed{XPath expressions} that select multiple nodes within a referenced model, when used within a \concept{\element{target}} attribute, a single element or attribute \emph{must} be selected by the expression.

\begin{blockChanged}
The \concept{\element{target}} attribute may also be used in three situations to reference another SED-ML element with mathematical meaning, by containing a fragment identifier consisting of a hash character (\code{\#}) followed by the \SId of the element (i.e. \val{\#id001}).

The first situation is a \Variable inside a \RepeatedTask, which may use a \element{target} to reference a \Range.  In this situation, the \Variable has the mathematical meaning of the scalar value of the \Range for that iteration of the \RepeatedTask.

The second situation is that any \Variable may use a \element{target} to reference a scalar \DataSource.  In this situation, the \Variable has the mathematical meaning of that scalar value.

The final situation is a \Variable inside a \DataGenerator, which may use a \element{target} to reference a multidimensional \DataSource.  In this situation, the \Variable has the mathematical meaning of the referenced external data.  If the \element{id} of the \Variable is used inside a \Math element, any function applied to it is assumed to apply to each individual scalar value of that data.

There are no other situations in SED-ML where the \element{id} of a SED-ML element may be used as the \element{target} of a \Variable.  Also note that multidimensional \DataSource ids may not be used in \RepeatedTask elements, nor \Range ids in \DataGenerator elements.  (To access multidimensional data for a \Range, a \DataRange may be used instead.)
\end{blockChanged}

\lsttexta{target}{target}
In the example the \concept{\element{target}} is used to reference a species with \element{id='PY'} in an SBML model.
\begin{myXmlLst}{SED-ML \code{target} definition}{lst:target}
<listOfVariables>
	<variable id="v1" name="TetR protein" taskReference="task1" 
		target="/sbml:sbml/sbml:listOfSpecies/sbml:species[@id='PY']" />
</listOfVariables>
\end{myXmlLst}

It should be noted that the identifiers and names inside the SED-ML document do not have to match the identifiers and names that the model and its constituents have in the model definition. In Listing \ref{lst:target}, the variable with ID \code{v1} is defined. It is described as \code{TetR protein}. The reference points to a species in the referenced SBML model. The particular species can be identified through its ID in the SBML model, namely \code{PY}. However, SED-ML also permits using identical identifiers and names as in the referenced models. The following Listing~\vref{lst:sedmlVariable} is another valid example for the specification of a variable, but uses the same naming in the variable definition as in the original model (as opposed to Listing~\ref{lst:target}):

\begin{myXmlLst}{SED-ML variable definition using the original model identifier and name in SED-ML}{lst:sedmlVariable}
<listOfVariables>
	<variable id="PY" name="TetR protein"  taskReference="task1" 
		target="/sbml:sbml/sbml:listOfSpecies/sbml:species[@id='PY']" />
</listOfVariables>
\end{myXmlLst}

\begin{myXmlLst}{Species definition in the referenced model}{lst:sbmlModel}
<sbml [..]>
	<listOfSpecies>
		<species metaid="PY" id="PY" name="TetR protein" [..]>
		[..]
		</species>
 	</listOfSpecies>
 	[..]
</sbml>
\end{myXmlLst}

The \hyperref[sec:xpath]{XPath} expression used in the \concept{\code{target}} attribute unambiguously leads to the particular place in the SBML model, i.e., the species is to be found in the \emph{sbml} element, and there inside the \emph{listOfSpecies} (Listing~\ref{lst:sbmlModel}). 



% ~~~ SYMBOL ~~~
\paragraph*{\element{symbol}}
\label{sec:symbol}
The \concept{\element{symbol}} \changed{attribute of type \element{string} is used to refer either to a predefined, implicit variable or to a predefined implicit function to be performed on the \element{target}.  In both cases, the \element{symbol} should be a \kisaoID (and follow the format of that attribute) that represents} that variable's concept. The notion of implicit variables is explained in Section~\ref{sec:implicitVariable}.  \changed{For backwards compatibility, the old string \val{urn:sedml:symbol:time} is also allowed, though interpreters should interpret \val{KISAO:0000832} as meaning the same thing.}

\changed{In the case where the \element{symbol} refers to a function, the function is applied to the \element{target} of the \Variable.  If the function reduces the dimensionality of the \Variable, at least one \AppliedDimension child should be used.}

\lsttexta{symbol}{symbol}
The example \changed{encodes a variable \val{t1} defined to be the SED-ML symbol for \code{time}.  How to use this variable to calculate a change is} explained in Section~\ref{class:computeChange}.

\begin{myXmlLst}{SED-ML \code{symbol} definition}{lst:symbol}
<listOfVariables>
	<variable id="t1" name="time" taskReference="task1" symbol="KISAO:0000832" />
</listOfVariables>
\end{myXmlLst}

% ~~~ TASK REFERENCE ~~~
\paragraph*{\element{taskReference}}
\label{sec:taskReferenceAttribute}
The \concept{\element{taskReference}} element of data type \SIdRef is used to reference a \Task via a \hyperref[sec:taskReference]{taskReference}. The usage depends on the context the \Variable is used in.

% ~~~ MODEL REFERENCE ~~~
\paragraph*{\element{modelReference}}
\label{sec:modelReferenceAttribute}
The \concept{\element{modelReference}} element of data type \SIdRef is used to reference a \Model via a \hyperref[sec:modelReference]{modelReference}. The usage depends on the context the \Variable is used in.


\begin{blockChanged}
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% APPLIEDDIMENSION
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{AppliedDimension}}
\label{class:appliedDimension}
\label{class:listOfAppliedDimensions}

An \AppliedDimension object is used when the \element{term} of the \Variable is a function that reduces the dimensionality of the data.  For example, a variable derived from a \Task inside a \RepeatedTask will have the dimensionality of both.  If the \element{term} of the parent \Variable is the `mean' function (\val{KISAO:0000825}), the following options are available:

\begin{itemize}
        \item The \Variable contains a single \AppliedDimension child that refers to the \RepeatedTask.  The resulting data will have the same dimensions as if the \Variable referred directly to the \Task, but averaged over every repeat of the \RepeatedTask.  This situation is particularly common when the \Task is a stochastic time course simulation, and the \RepeatedTask is a simple loop of that \Task.
        \item The \Variable contains a single \AppliedDimension child that refers to the \Task.  The resulting data will be a vector with the same number of entries as there were repeats of the \RepeatedTask.  This situation is particularly helpful when the \RepeatedTask is a parameter scan, and the \Variable is tracking a model variable that oscillates during the \Task.  The resulting vector will be the average value of that model variable under each of the different starting conditions.
        \item The \Variable contains two \AppliedDimension children, one that refers to the \RepeatedTask and one to the \Task.  The resulting data will be a single value, that has been averaged over both the \Task and \RepeatedTask.  In this case, the function is performed on an element-by-element basis
\end{itemize}

The \element{term} of the parent \Variable with one or more \AppliedDimension children should always reference a function that reduces the dimensionality of the data (i.e. children of \element{KISAO:0000824}).

%In the second case, the \Variable is multidimensional, but some of those dimensions involve a \Task that does not reference the \Model from which the \Variable is drawn.  In these cases, if the \Variable is given \AppliedDimension children for the tasks that change the relevant \Model, but not the ones that do not, the resulting data will not include the dimension where the \Variable's \Model was not involved.


An \AppliedDimension inherits the attributes and children of \SedBase, and adds the attributes \element{target} (of type \SIdRef), and \element{dimensionTarget} (of type \element{NuMLIdRef}), both of which are optional, but one of which must be present.

\paragraph*{\element{target}}
The \element{target} attribute of an \AppliedDimension is used when the applied dimension is a \Task or \RepeatedTask, which must be implicitly involved in the construction of the dimensionality of the parent \Variable.

Possible values for the \element{target} attribute include:
\begin{itemize}
        \item The id of a \RepeatedTask
        \item The id of a \Task referenced by a \RepeatedTask
        \item The id of a \SubTask child of a \RepeatedTask
\end{itemize}

\paragraph*{\element{dimensionTarget}}
The \element{dimensionTarget} attribute of an \AppliedDimension is used when the \Variable references an external data set.  The \element{NuMLIdRef} must reference a dimension of the referenced data.


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% DEPENDENTVARIABLE
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{DependentVariable}}
\label{class:dependentVariable}

The \DependentVariable object is a child of the \Variable class, extending it to include three new attributes:  \element{term} (of type \element{string}), \element{target2} (of \changed{type \element{TargetType}}), and \element{symbol2} (of type string).  A dependent variable is necessary when the desired variable is a composite of two other variables, such as `the rate of change of S1 with respect to time'.

In a \DependentVariable, the \element{term} is used to define an analysis to be performed on the model as a whole, or the relationship of the two variables (i.e. `rate of change'), the \element{target} or \element{symbol} attributes are used to define the first such variable, and the new \element{target2} and \element{symbol2} is used to define the second variable.  

\paragraph*{\element{term}}
\label{sec:term}
The \element{term} attribute is of type \element{string}, and should conform to the syntax of a \kisaoID, though the string \val{urn:sedml:symbol:time} may be used for backwards compatibility.  The \element{term} may refer to a function (such as `rate of change', \code{KISAO:0000834}) that relates two variables to each other, instead of just one, or it may refer to an analysis (such as 'the eigenvalue matrix', \code{KISAO:0000813}) that is dependent on the model as a whole and not on individual model elements.

\paragraph*{\element{target2}}
\label{sec:target2}
A \element{target2} attribute has exactly the same constraints and behavior as a \element{target} attribute, but refers to a second mathematical element.

\paragraph*{\element{symbol2}}
\label{sec:symbol2}
A \element{symbol2} attribute has exactly the same constraints and behavior as a \element{symbol} attribute, but refers to a second mathematical element.


\begin{myXmlLst}{SED-ML dependent variable definition of 'the rate of change of S1 with respect to time'}{lst:sedmlDependentVariable}
<listOfVariables>
	<dependentVariable id="S1prime" name="S1'"  taskReference="task1"
		term="KISAO:0000834"
		target="/sbml:sbml/sbml:listOfSpecies/sbml:species[@id='S1']"
		symbol2="KISAO:0000832" />
</listOfVariables>
\end{myXmlLst}


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% CALCULATION
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{Calculation}}
\label{class:calculation}
\label{class:listOfVariables}
\label{class:listOfParameters}

The \Calculation class is an abstract base class for the \ComputeChange, \DataGenerator, and \FunctionalRange classes (defined later).  A \Calculation inherits from \SedBase, and adds three children:  a required \Math child, and optional lists of \Variable and \Parameter objects.  In all three of its uses, it performs a calculation that optionally may depend on locally-defined elements.  This abstract class is provided for convenience, since all three other classes contain this same relatively complicated structure.  However, as \FunctionalRange also inherits from \Range, and \ComputeChange also inherits from \Change, implementations may choose to simply re-instantiate the child elements of \Calculation on these or other derived classes, in environments where multiple inheritance is illegal or infeasible.

\sedfig[width=0.9\textwidth]{images/uml/calculation}{The \Calculation, \Math, \ListOfVariables, \ListOfParameters, and \Parameter classes.}{fig:calculation}

In the \ListOfVariables, the \Variable elements define identifiers referring to model variables or range values, which may then be used within the \Math expression. These references always retrieve the current value of the variable in the context of the \Calculation.  A \ListOfVariables may contain any number of \Variable and/or \DependentVariable entries.

In the \ListOfParameters, the \Parameter elements define simple values that may be used in the \Math of the \Calculation.

The \Math encompasses the mathematical expression that is used to compute the value for the \Calculation.

% ~~~ MATH ~~~
\subsubsection{\element{Math}}
\label{sec:math}
A \Calculation's mandatory child element \concept{\element{math}} contains a MathML expression used to calculate a value in the context of the \Calculation.  The available subset of mathematical functions and elements which can be used in the \Math element are listed in Section~\hyperref[sec:mathML]{MathML}.


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% GENERAL ATTRIBUTES
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{General attributes and elements}
This section describes attributes which occur on multiple SED-ML classes, e.g., \kisaoID, or \hyperref[class:listOf]{\element{listOf*}} constructs.
\label{sec:generalAttributes}

\end{blockChanged}
% ~~~ KISAOID ~~~
\subsubsection{\element{kisaoID}}
\label{sec:kisaoid}
Some classes, e.g., \hyperref[class:algorithm]{Algorithm} and \hyperref[class:algorithmParameter]{AlgorithmParameter}, have a mandatory element \concept{\element{kisaoID}} \changed{or another attribute} which references a term from the \hyperref[sec:kisao]{KiSAO} ontology. The referenced term must be defined in the correct syntax, as defined by the regular expression \code{\textasciicircum KISAO:[0-9]\{7\}\$}. The referenced \hyperref[sec:kisao]{KiSAO} term  should define the simulation \hyperref[class:algorithm]{Algorithm} or \hyperref[class:algorithmParameter]{AlgorithmParameter} as precisely as possible.  \changed{Note that the use of a colon predates KiSAO's switch to using an underscore in official KiSAO URLs.  We continue to use the colon here for backwards compatibility, and because a \element{kisaoID} is not a URL.}


% ~~~ LISTOF ~~~
\subsubsection{\element{listOf*} containers}
\label{class:listOf}
SED-ML \concept{\element{listOf*}} elements serve as containers for a collection of objects of the same type. For example, the \hyperref[class:listOfModels]{\element{listOfModels}} contains all \Model objects of a SED-ML document. Lists do not carry any further semantics nor do they add additional attributes. They might, however, be annotated with \Notes and \Annotation as they are derived from \hyperref[class:sedBase]{SEDBase}. All \concept{\element{listOf*}} elements are optional in a SED-ML document (with exception of \hyperref[class:listOfRanges]{\element{listOfRanges}} and \hyperref[class:subTask]{\element{listOfSubTasks}} in a \RepeatedTask, which are mandatory).


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% REFERENCE RELATION
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{Reference relations}
\label{sec:reference}

The \concept{reference} concept is used to refer to a particular element inside the SED-ML document. It may occur as an association between:

\begin{itemize}
	\item{two \Models (\hyperref[sec:modelReference]{modelReference})}
	\item{a \Variable and a \Model (\hyperref[sec:modelReference]{modelReference})}
	\item{a \Variable and an \AbstractTask (\hyperref[sec:taskReference]{taskReference})}
	\item{a \Task and the simulated \Model (\hyperref[sec:modelReference]{modelReference})}
	\item{a \Task and the \Simulation (\hyperref[sec:simulationReference]{simulationReference})}
	\item{an \hyperref[class:output]{Output} and a \DataGenerator (\hyperref[sec:dataReference]{dataReference})}
\end{itemize}

The definition of a \Task requires a reference to a particular \Model object (\hyperref[sec:modelReference]{modelReference}); furthermore, the \hyperref[class:abstractTask]{Task} object must be associated with a particular \Simulation object (\hyperref[sec:simulationReference]{simulationReference}).

Depending on the use of the \concept{reference} relation in connection with a \Variable object, it may take different roles: 

\begin{enumerate}
\item[a.]{The \concept{reference} association might occur between a \Variable object and a \Model object, e.g., if the variable is to define a \hyperref[class:change]{Change}. 
In that case the \code{variable} element contains a \hyperref[sec:modelReference]{modelReference} to refer to the particular model that contains the variable used to define the change.}

\item[b.]{If the \concept{reference} is used as an association between a \Variable object and an \AbstractTask object inside the \hyperref[class:dataGenerator]{dataGenerator} class, then the \code{variable} element contains a \hyperref[sec:taskReference]{taskReference} to unambiguously refer to an observable in a given task.}
\end{enumerate}


% ~~~ MODEL REFERENCE ~~~
\subsubsection{modelReference}
\label{sec:modelReference}
The \concept{modelReference} is a \hyperref[sec:reference]{reference} used to refer to a particular \Model via a \SIdRef. The \concept{modelReference} either represents a relation between two \Model objects, a \Variable object and a \Model object, or a relation between a \Task object and a \Model object.

The \hyperref[sec:model_source]{\code{source}} attribute of a \Model is allowed to reference either a URI or an \SId of a second \Model. Circular constructs where a model \code{A} refers to a model \code{B} and \code{B} to \code{A} (directly or indirectly) are invalid.

If pre-processing needs to be applied to a model before simulation, then the model update can be specified by creating a \hyperref[class:change]{Change} object. In the particular case that a change must be calculated with a mathematical function, variables need to be defined. To refer to an existing entity in a defined \Model, the \concept{modelReference} is used. 

The \code{modelReference} attribute of the \code{variable} element contains the \concept{id} of a model that is defined in the document. 

\lsttext{modelReference1}{modelReference} 
In the example, a change is  applied on model \code{m0001}. In the \code{computeChange} element a list of variables is defined. One of those variable is \code{v1} which is defined in another model (\code{cellML}). The \hyperref[sec:xpath]{XPath} expression given in the \hyperref[sec:target]{target} attribute identifies the variable in the model which carries the ID \code{cellML}.
\begin{myXmlLst}{SED-ML \code{modelReference} attribute inside a variable definition of a \code{computeChange} element}{lst:modelReference1}
<model id="m0001" [..]>
	<listOfChanges>
		<computeChange>
			<listOfVariables>
				<variable id="v1" modelReference="cellML" target="/cellml:model/cellml:component[@cmeta:id='MP']/cellml:variable[@name='vsP']/@initial_value" />
     			[..]
			</listOfVariables>
			<listOfParameters [..] />
    			<math>
     			[CALCULATION OF CHANGE]
    			</math>
   		</computeChange>
	</listOfChanges>
	[..]
</model>
\end{myXmlLst}

The \concept{modelReference} is also used to indicate that a \Model object is used in a particular  \Task. Listing \ref{lst:modelReference2} shows how this can be done for a sample SED-ML document.

\begin{myXmlLst}{SED-ML \code{modelReference} definition inside a \element{task} element}{lst:modelReference2}
<listOfTasks>
	<task id="t1" name="Baseline" modelReference="model1" simulationReference="simulation1" />
	<task id="t2" name="Modified" modelReference="model2" simulationReference="simulation1" />
</listOfTasks>
\end{myXmlLst}

The example defines two different tasks; the first one applies the simulation settings of \code{simulation1} on \code{model1}, the second one applies the same simulation settings on \code{model2}.


% ~~~ SIMULATION REFERENCE ~~~
\subsubsection{simulationReference}
\label{sec:simulationReference}
The \concept{simulationReference} is used to refer to a particular \Simulation  via a \SIdRef, e.g., in a \Task. 

Listing \ref{lst:modelReference2} shows the reference to a defined simulation for a sample SED-ML document. In the example, both tasks \code{t1} and \code{t2} use the simulation settings defined in \code{simulation1} to run the experiment.


% ~~~ TASK REFERENCE ~~~
\subsubsection{taskReference}
\label{sec:taskReference}
The \concept{taskReference} is a \hyperref[sec:reference]{reference} used to refer to a particular \AbstractTask via a \SIdRef. The \concept{taskReference} is used in \SubTask to reference the respective subtask, or in \Variable within a \DataGenerator.

\DataGenerator objects are created to apply post-processing to the simulation results before final output. 
For certain types of post-processing \Variable objects need to be created.
These link to a \hyperref[class:abstractTask]{task} defined within the \ListOfTasks from which the model that contains the variable of interest can be inferred. A \concept{taskReference} association is used to realise that link from a \Variable object inside a \DataGenerator to an \AbstractTask object. Listing \ref{lst:reference3} gives an example.

\begin{myXmlLst}{SED-ML \code{taskReference} definition inside a \element{dataGenerator} element}{lst:reference3}
<listOfDataGenerators>
	<dataGenerator id="tim3" name="tim mRNA (difference v1-v2+20)">
	<listOfVariables>
   		<variable id="v1" taskReference="t1" [..] />
  	</listOfVariables>
  	<math [..]/>
	</dataGenerator>
</listOfDataGenerators>
\end{myXmlLst}

The example shows the definition of a variable \code{v1} in a \code{dataGenerator} element. The variable appears in the model that is used in task \code{t1}. The task definition of \code{t1} might look as shown in Listing~\ref{lst:taskReferences}.

\begin{myXmlLst}{Use of the reference relations in a task definition}{lst:taskReferences}
<listOfTasks>
	<task id="t1" name="task definition" modelReference="model1" simulationReference="simulation1" />
</listOfTasks>
\end{myXmlLst}
Task \code{t1} references the model \code{model1}. Therefore we can conclude that the variable \code{v1} defined in \lst{reference3} targets an element of the model with ID \code{model1}. The targeting process itself will be explained in section \ref{sec:target} on \refpage{sec:target}.

