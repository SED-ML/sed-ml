% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% ABSTRACT TASK
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{AbstractTask}}
\label{class:abstractTask}
In SED-ML the subclasses of \concept{AbstractTask} define which \Simulations should be executed with which \Models in the simulation experiment. \concept{AbstractTask} is the base class of all SED-ML tasks, i.e.\ \Task and \RepeatedTask.  \changed{It inherits the attributes and children of \SedBase, but changes the \element{id} attribute to be required instead of optional.}

\sedfig[width=0.80\textwidth]{images/uml/abstractTask}{The SED-ML Abstract Task, Task, RepeatedTask, and SimpleRepeatedTask classes}{fig:abstractTask}


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% TASK
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsubsection{\element{Task}}
\label{class:task}

A \concept{Task} links a \Model to a certain \Simulation description via their respective identifiers (\fig{abstractTask}), using the \hyperref[sec:modelReference]{\element{modelReference}} and the \hyperref[sec:simulationReference]{\element{simulationReference}}. The task class inherits the attributes and children of the \AbstractTask.

\paragraph*{\element{modelReference}}
The \element{modelReference} attribute of type \SIdRef must refer to a \Model.  Inside a \RepeatedTask, the state of the model may have been changed, but in parallel tasks, a \Model is to assume to its initial state.

\paragraph*{\element{simulationReference}}
the \element{simulationReference} attribute of type \SIdRef must refer to a \Simulation.

In SED-ML it is only possible to link one \Simulation description to one \Model at a time. However, one can define as many tasks as needed within one experiment description. Please note that the tasks may be executed in any order, as determined by the implementation.


In the example, a simulation setting \code{simulation1} is applied first to \code{model1} and then to \code{model2}.
\begin{myXmlLst}{The \code{task} element}{lst:task}
<listOfTasks>
	<task id="t1" name="task definition" modelReference="model1" 
		simulationReference="simulation1" />
	<task id="t2" name="another task definition" modelReference="model2" 
		simulationReference="simulation1" />
</listOfTasks>
\end{myXmlLst}


\begin{blockChanged}
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% SIMPLEREPEATED TASK
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsubsection{\element{SimpleRepeated Task}}
\label{class:simpleRepeatedTask}
The \concept{SimpleRepeatedTask} inherits from \Task, and provides a simplified looping construct that performs the \Task multiple times, resetting the model or not, according to its \element{resetModel} attribute.  The task itself is defined by the \element{modelReference} and \element{simulationReference} attributes it inherits from \Task.

\paragraph*{\element{resetModel}}
The \element{resetModel} attribute, of type \element{boolean} defines whether, for each execution of the simulation, the model is to be reset (\val{true}) or not (\val{false}).

\paragraph*{\element{numRepeats}}
The \element{numRepeats}, of type \element{positive integer}, defines the number of times the simulation is to be performed.
\end{blockChanged}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% REPEATED TASK
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsubsection{\element{Repeated Task}}
\label{class:repeatedTask}
The \concept{RepeatedTask} (\fig{repeatedTask}) provides a generic looping construct, allowing complex tasks to be composed from individual steps. The \concept{RepeatedTask} performs a specified task (or sequence of tasks as defined in the \hyperref[class:listOfSubTasks]{\element{listOfSubTasks}}) multiple times (where the exact number is specified through a \Range construct as defined in \hyperref[sec:rangeAttribute]{\element{range}}), while allowing specific quantities in the model to be altered at each iteration (as defined in the \hyperref[sec:changesRepeatedTask]{\element{listOfChanges}}).

\sedfig[width=.8\textwidth]{images/uml/repeatedTask}{The SED-ML RepeatedTask class}{fig:repeatedTask}

The \concept{RepeatedTask} inherits the required attribute \hyperref[sec:id]{\element{id}} and optional attribute \hyperref[sec:name]{\element{name}} from \AbstractTask. Additionally it has the two required attributes \hyperref[sec:rangeAttribute]{\element{range}} and \hyperref[sec:resetModel]{\element{resetModel}} and the child elements \hyperref[class:listOfRanges]{\element{listOfRanges}}, \hyperref[sec:changesRepeatedTask]{\element{listOfChanges}} and \hyperref[class:subTask]{\element{listOfSubTasks}}. Of these \hyperref[class:listOf]{\element{listOf*}} only \hyperref[sec:changesRepeatedTask]{\element{listOfChanges}} is optional.

The order of activities within each iteration of a \concept{RepeatedTask} is as follows:
\begin{itemize} 
	\item The \Model is reset if specified by the \hyperref[sec:resetModel]{\element{resetModel}} attribute. 
	\item Any changes to the model specified by \hyperref[class:setValue]{SetValue} objects in the \hyperref[sec:changesRepeatedTask]{\element{listOfChanges}} are applied to the \Model. 
	\item Finally, all \hyperref[class:subTask]{{subTasks}} in the \hyperref[class:listOfSubTasks]{\element{listOfSubtasks}} are executed in the order specified by their \hyperref[sec:subTaskOrder]{\element{order}} element.
\end{itemize}


\lsttext{repeatedTask}{repeatedTask}
In the example, \code{task1} is repeated three times, each time with a different value for a model parameter \code{w}.
\begin{myXmlLst}{The \code{repeatedTask} element}{lst:repeatedTask}
<task id="task1" modelReference="model1" simulationReference="simulation1" />
<repeatedTask id="task3" resetModel="false" range="current"
    xmlns:s='http://www.sbml.org/sbml/level3/version1/core'>
  <listOfRanges>
    <vectorRange id="current"> 
        <value> 1 </value> 
        <value> 4 </value> 
        <value> 10 </value> 
    </vectorRange> 
  </listOfRanges>
  <listOfChanges>
     <setValue target="/s:sbml/s:model/s:listOfParameters/s:parameter[@id='w']" modelReference="model1">
       <listOfVariables> 
         <variable id="val" name="current range value" target="#current" /> 
       </listOfVariables> 
       <math xmlns="http://www.w3.org/1998/Math/MathML"> 
         <ci> val </ci> 
       </math> 
     </setValue> 
  </listOfChanges>
  <listOfSubTasks>
    <subTask task="task1" />
  </listOfSubTasks>
</repeatedTask>
\end{myXmlLst}
 
% ~~~ RANGE ~~~
\paragraph*{\element{range}}
\label{sec:rangeAttribute}
The \RepeatedTask has a required attribute \concept{\element{range}} of type \SIdRef. It specifies which \concept{\element{range}} defined in the \hyperref[class:listOfRanges]{\element{listOfRanges}} this repeated task iterates over. Listing~\ref{lst:repeatedTask} shows an example of a \hyperref[class:repeatedTask]{repeatedTask} iterating over a single range comprising the values: \code{1}, \code{4} and \code{10}.
If there are multiple ranges in the \hyperref[class:listOfRanges]{\element{listOfRanges}}, then only the master \concept{\element{range}} identified by this attribute determines how many iterations there will be in the \hyperref[class:repeatedTask]{repeatedTask}. All other ranges must allow for at least as many iterations as the master range, and will be moved through in lock-step; their values can be used in \hyperref[class:setValue]{setValue} constructs.

% ~~~ RESET MODEL ~~~
\paragraph*{\element{resetModel}}
\label{sec:resetModel}
The \hyperref[class:repeatedTask]{repeatedTask} has a required attribute \concept{\element{resetModel}} of type \code{boolean}. It specifies whether the model should be reset to the initial state before processing an iteration of the defined \hyperref[class:subTask]{subTasks}. Here initial state refers to the state of the model as given in the \hyperref[class:listOfModels]{\element{listOfModels}}.

In the example in  Listing~\ref{lst:repeatedTask} the repeated task is not to be reset, so a change is made, \code{task1} is carried out, another change is made, then \code{task1} continues from there, another change is applied, and \code{task1} is carried out a last time.

%% ~~~ LIST OF CHANGES ~~~
\paragraph*{\element{listOfChanges}}
\label{sec:changesRepeatedTask}
The optional \concept{\element{listOfChanges}} element contains one or many \hyperref[class:setValue]{SetValue} elements. These elements allow the modification of values in the model prior to the next iteration of the \RepeatedTask.

%% ~~~ REPEATED TASK : LIST OF SUBTASKS ~~~
\paragraph*{\element{listOfSubTasks}}
\label{class:listOfSubTasks}
The required \concept{\element{listOfSubTasks}} contains one or more \hyperref[class:subTask]{subTasks} that specify which \hyperref[class:abstractTask]{Tasks} are performed in every iteration of the \RepeatedTask. All \hyperref[class:subTask]{subTasks} have to be carried out sequentially, each continuing from the current model state (i.e.\ as at the end of the previous \hyperref[class:subTask]{subTask}, assuming it simulates the same model), and with their results concatenated (thus appearing identical to a single complex simulation). The order in which to run multiple \hyperref[class:subTask]{subTasks} must be specified using the \hyperref[sec:subTaskOrder]{\element{order}} attribute on the \hyperref[class:subTask]{subTask}. 

\begin{myXmlLst}{The \code{subTask} element. In this example the task \code{task2} must be executed before \code{task1}.}{lst:subTask}
<listOfSubTasks>
	<subTask task="task1" order="2"/> 
	<subTask task="task2" order="1"/> 
</listOfSubTasks>
\end{myXmlLst}

% ~~~ LIST OF RANGES ~~~
\paragraph*{\element{listOfRanges}}
\label{class:listOfRanges}
The \concept{\element{listOfRanges}} defines one or more \hyperref[class:range]{ranges} used in the \hyperref[class:repeatedTask]{repeatedTask}.

A \Range is the iterative element of the repeated simulation experiment. Each \Range defines a collection of values to iterate over. The \hyperref[sec:id]{\element{id}} attribute of the ranges can be used to refer to the current value of a range. When the \hyperref[sec:id]{\element{id}} attribute is used in a \hyperref[class:listOfVariables]{listOfVariables} within the \RepeatedTask its value is to be replaced with the current value of the \Range.
%% ? IS THIS CORRECT ? I.e. is it necessary to define a variable with the range id, or is it 
% sufficient to use math with the id.


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% TASK COMPONENTS
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{\element{Task} components}
\label{class:taskComponents}

% ~~~ SUBTASK ~~~
\subsubsection{\element{SubTask}}
\label{class:subTask}
A \concept{SubTask} (\fig{repeatedTask}) defines the subtask which is executed in every iteration of the enclosing \RepeatedTask. The \concept{SubTask} has a required attribute \hyperref[sec:subTaskTask]{\element{task}} that references the \hyperref[sec:id]{\element{id}} of another \AbstractTask. The order in which to run multiple \concept{subTasks} must be specified via the required attribute \hyperref[sec:subTaskOrder]{\element{order}}. 

\paragraph*{\element{task}}
\label{sec:subTaskTask}
The required element \concept{\element{task}} of data type \SIdRef specifies the \AbstractTask executed by this \SubTask.

\paragraph*{\element{order}}
\label{sec:subTaskOrder}
The required attribute \concept{\element{order}} of data type \element{integer} specifies the order in which to run multiple \concept{subTasks} in the \hyperref[class:listOfSubTasks]{\element{listOfSubTasks}}. To specify that one \concept{subTask} should be executed before another its \concept{\element{order}} attribute must have a lower number (e.g.\ in Listing~\ref{lst:subTask}).


% ~~~ SET VALUE ~~~
\subsubsection{\element{SetValue}}
\label{class:setValue}
The \concept{SetValue} class (\fig{repeatedTask}) allows the modification of the \hyperref[class:model]{model} prior to the next execution of the \hyperref[class:subTask]{subTasks}. The changes to the model are defined in the \hyperref[sec:changesRepeatedTask]{\element{listOfChanges}} of the \RepeatedTask.

\concept{SetValue} inherits from the \ComputeChange class, which allows it to compute arbitrary expressions involving a number of \hyperref[class:variable]{variables} and \hyperref[class:parameter]{parameters}. \concept{SetValue} has a mandatory \element{modelReference} attribute, and the optional attributes \element{range} and \element{symbol}.

The value to be changed is identified via the combination of the attributes \code{modelReference} and either \code{symbol} or \code{target}, in order to select an implicit or explicit variable within the referenced model.

As in \hyperref[class:functionalRange]{functionalRange}, the attribute \code{range} may be used as a shorthand to specify the \code{id} of another \concept{Range}. The current value of the referenced range may then be used within the function defining this \concept{FunctionalRange}, just as if that range had been referenced using a \hyperref[class:variable]{variable} element, except that the \code{id} of the range is used directly. In other words, whenever the expression contains a \code{ci} element that contains the value specified in the \code{range} attribute, the value of the referenced range is to be inserted.

The \Math contains the expression computing the value by referring to optional \hyperref[class:parameter]{parameters}, \hyperref[class:variable]{variables} or \hyperref[class:range]{ranges}.
Again as for \hyperref[class:functionalRange]{functionalRange}, variable references retrieve always the current value of the model variable or range at the current iteration of the enclosing \hyperref[class:repeatedTask]{repeatedTask}.

\begin{myXmlLst}{A \code{setValue} element setting \code{w} to the values of the range with id \code{current}.}{lst:setValue}
<listOfChanges>
	<setValue target="/s:sbml/s:model/s:listOfParameters/s:parameter[@id='w']"
		range="current" modelReference="model1">
		<math xmlns="http://www.w3.org/1998/Math/MathML">
			<ci> current </ci>
		</math>
	</setValue>
</listOfChanges>
\end{myXmlLst}

% missing attribute descriptions for consistency
% \paragraph*{range}
% \paragraph*{symbol}
% \paragraph*{range}
% \paragraph*{modelReference}


% ~~~ RANGE ~~~
\subsubsection{\element{Range}}
\label{class:range}
The \concept{Range} class is the abstract base class for the different types of ranges, i.e. \UniformRange, \VectorRange, and \FunctionalRange (\fig{range}). 

\sedfig[width=1.0\textwidth]{images/uml/range}{The SED-ML Range class}{fig:range}

\paragraph{\element{UniformRange}}
\label{class:uniformRange}
The \concept{UniformRange} (\fig{range}) allows the definition of a \Range with uniformly spaced values. In this it is quite similar to what is used in the \hyperref[class:uniformTimeCourse]{UniformTimeCourse}. The \concept{UniformRange} is defined via three mandatory attributes: \element{start}, the start value; \element{end}, the end value and \code{numberOfPoints} which defines defines the number of points in addition to the start value (the actual items in the range are \code{numberOfPoints+1}). A fourth attribute \code{type} that can take the values \code{linear} or \code{log} determines whether to draw the values logarithmically (with a base of $10$) or linearly.

For example, the following \concept{UniformRange} will produce \code{101} values uniformly spaced on the interval \code{$[0, 10]$} in ascending order.
\begin{myXmlLst}{The \code{UniformRange} element}{lst:uniformRange}
<uniformRange id="current" start="0.0" end="10.0" numberOfPoints="100" type="linear" /> 
\end{myXmlLst}

The following logarithmic example generates the three values \code{1}, \code{10} and \code{100}.
\begin{myXmlLst}{The \code{UniformRange} element with a logarithmic range.}{lst:uniformRangeLog}
<uniformRange id="current" start="1.0" end="100.0" numberOfPoints="2" type="log" />
\end{myXmlLst}

\paragraph{\element{VectorRange}}
\label{class:vectorRange}

The \concept{VectorRange} (\fig{range}) describes an ordered collection of real values, listing them explicitly within child \hyperref[class:value]{\element{value}} elements.

For example, the range below iterates over the values $1$, $4$ and $10$ in that order.
\begin{myXmlLst}{The \code{VectorRange} element}{lst:vectorRange}
<vectorRange id="current"> 
	<value> 1 </value> 
	<value> 4 </value> 
	<value> 10 </value> 
</vectorRange> 
\end{myXmlLst}

\paragraph{\element{Value}}
\label{class:value}
The \concept{Value} (\fig{range}) describes a single value, e.g., the \concept{Value}s in a \VectorRange.

\paragraph{\element{FunctionalRange}}
\label{class:functionalRange}
The \concept{FunctionalRange} (\fig{range}) constructs a range through calculations that determine the next value based on the value(s) of other range(s) or model variables. In this it is similar to the \ComputeChange element, and shares some of the same child elements (but is no subclass of \ComputeChange). It consists of an optional attribute \code{range}, two optional elements \ListOfVariables and \ListOfParameters, and a required element \Math.

The optional attribute \code{range} of type \hyperref[type:sidref]{SIdRef} may be used as a shorthand to specify the \hyperref[sec:id]{\element{id}} of another \Range. The current value of the referenced range may then be used within the function defining this \concept{FunctionalRange}, just as if that range had been referenced using a \hyperref[class:variable]{variable} element, except that the \hyperref[sec:id]{\element{id}} of the range is used directly. In other words, whenever the expression contains a \code{ci} element that contains the value specified in the \code{range} attribute, the value of the referenced range is to be inserted.

For example:

\begin{myXmlLst}{An example of a \code{functionalRange} where a parameter \code{w} of model \code{model2} is multiplied by \code{index} each time it is called.}{lst:functionalRange}
<functionalRange id="current" range="index"
	xmlns:s='http://www.sbml.org/sbml/level3/version1/core'>
	<listOfVariables>
		<variable id="w" name="current parameter value" modelReference="model2"
			target="/s:sbml/s:model/s:listOfParameters/s:parameter[@id='w']" />
	</listOfVariables>
	<math xmlns="http://www.w3.org/1998/Math/MathML">
	  <apply>
	    <times/>
		  <ci> w </ci>
          <ci> index </ci>
      </apply>
	</math>
</functionalRange>
\end{myXmlLst}

Here is another example, this time using the values in a piecewise expression: 

\begin{myXmlLst}{A \code{functionalRange} element that returns \code{8} if \code{index} is smaller than \code{1}, \code{0.1} if \code{index} is between \code{4} and \code{6}, and \code{8} otherwise.}{lst:functionalRange2}
<uniformRange id="index" start="0" end="10" numberOfPoints="100" />
<functionalRange id="current" range="index">
	<math xmlns="http://www.w3.org/1998/Math/MathML">
		<piecewise>
			<piece>
				<cn> 8 </cn>
				<apply>
					<lt />
					<ci> index </ci>
					<cn> 1 </cn>
				</apply>
			</piece>
			<piece>
				<cn> 0.1 </cn>
				<apply>
					<and />
					<apply>
						<geq />
                    	<ci> index </ci>
                    	<cn> 4 </cn>
					</apply>
					<apply>
						<lt />
						<ci> index </ci>
						<cn> 6 </cn>
					</apply>
				</apply>
			</piece>
			<otherwise>
				<cn> 8 </cn>
			</otherwise>
		</piecewise>
	</math>
</functionalRange>
\end{myXmlLst}

\begin{blockChanged}
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% REPEATED TASK
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsubsection{\element{ParameterEstimationTask}}
\label{class:parameterEstimationTask}

The \ParameterEstimationTask inherits from \AbstractTask.  Other than that, it has yet to be fully defined, but some people hope to get it into L1v4.  Further bulletins as events warrant.
\end{blockChanged}
