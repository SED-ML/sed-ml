 \subsection{\element{Repeated Task}}
\label{class:repeatedTask}

Instead of redefining a large number of simulation types to suite various simulation tasks, the \concept{repeatedTask} breaks down complex tasks into separate steps. The \concept{repeatedTask} performs a specified simulation multiple times (where the exact number is specified through a \hyperref[class:range]{range} construct while allowing specific aspects of the model to change (in the simplest case that would be by advancing the simulation time). The \concept{repeatedTask} defines a list of subtasks to be carried out sequentially. 

The \concept{RepeatedTask} inherits from \concept{AbstractTask}. Additionally it has two required attributes \hyperref[sec:rangeAttribute]{rangeAttribute} and \hyperref[sec:resetModel]{resetModel} as well as elements \hyperref[class:ranges]{listOfRanges}, \hyperref[class:changes]{listOfChanges} and \hyperref[class:subTasks]{listOfSubTasks}.

%
\sedfig[width=.90\textwidth]{repeatedTaskClass}{The SED-ML RepeatedTask class}{fig:sedTask}
%

\tabtext{repeatedTask}{repeatedTask}
%
\begin{table}[ht]
\center
\begin{tabular}{|l|l|}
\hline
\textbf{\attribute} & \textbf{\desc}\\
\hline
metaid$^{o}$ & \refpage{sec:metaID}\\
id & \refpage{sec:id} \\
name$^{o}$ & \refpage{sec:name}\\
\hline
range$^{o}$ & \refpage{sec:rangeAttribute}\\
resetModel$^{o}$ & \refpage{sec:resetModel}\\
\hline
\hline
\textbf{\subelements} & \textbf{\desc}\\
\hline
notes$^{o}$ & \refpage{class:notes}\\
annotation$^{o}$ & \refpage{class:annotation}\\
\hline
listOfRanges$^{o}$ & \refpage{class:ranges}\\
listOfChanges$^{o}$ & \refpage{class:changes}\\
listOfSubTasks$^{o}$ & \refpage{class:subTasks}\\
\hline
\hline
\end{tabular}
\caption{\tabcap{repeatedTask}}
\label{tab:repeatedTask}
\end{table}
%



\lsttext{repeatedTask}{repeatedTask}

%
\begin{myXmlLst}{The \code{repeatedTask} element}{lst:repeatedTask}
<task id="task1" modelReference="model1" simulationReference="simulation1" />
<repeatedTask id="task3" resetModel="false" range="current"> 
  <listOfRanges>
    <vectorRange id="current"> 
        <value> 1 </value> 
        <value> 4 </value> 
        <value> 10 </value> 
    </vectorRange> 
  </listOfRanges>
  <listOfChanges>
     <setValue target="/sbml/model/listOfParameters/parameter[@id='w']" modelReference="model1" > 
     <listOfVariables> 
         <variable id="val" name="current range value" target="#current" /> 
     </listOfVariables> 
     <math xmlns="http://www.w3.org/1998/Math/MathML"> 
         <ci> val </ci> 
     </math> 
    </setValue> 
</listOfChanges>
<listOfSubTasks>
  <subTask task="task1" />
</listOfSubTasks>
</repeatedTask>

\end{myXmlLst}
%
In the example, \code{task1} is repeated three times, each time with a different value for a model parameter \code{w}. 



\subsubsection{ The \element{range} attribute}
\label{sec:rangeAttribute}
The \element{repeatedTask} class has a required attribute \element{range} of type \code{SId}. It specifies which \hyperref[class:range]{range} defined in the \element{listOfRanges} that this repeated task iterates over. Listing~\ref{lst:repeatedTask} shows an example of a \element{repeatedTask} iterating over the values: \code{1}, \code{4} and \code{10}. 


\subsubsection{ The \element{resetModel} attribute}
\label{sec:resetModel}
The \element{repeatedTask} class has a required attribute \element{resetModel} of type \code{boolean}. It specifies whether the model should be reset to the initial state before processing an iteration of the defined \hyperref[class:subTasks]{subTasks}. Here initial state refers to the state of the model as given in the \element{listOfModels}.  In the example in  Listing~\ref{lst:repeatedTask} the repeated task is not to be reset, so \code{task1} is carried out, another change is being made, then \code{task1} continues from there, another change is applied, and \code{task1} is carried out a last time. 

\subsubsection{ The \element{listOfRanges}}
\label{class:ranges}
Ranges represent the iterative element of the nested simulation experiment that provides the collection of values to iterate over. In order to be able to refer to the current value of a range element, an \code{id} attribute is added. When the value of the \code{id} attribute is used in a \element{listOfVariables} within the repeated task class its value is to be replaced with the current value of the range.

There are three different range types: 

\paragraph{\element{UniformRange}}
\label{class:uniformRange}
The \element{UniformRange} is quite similar to what is used in the \element{UniformTimecourse} simulation class. This range is defined through four attributes: \code{start}, the start value; \code{end}, the end value and \code{numberOfPoints} that contains the number of points the range contains. A fourth attribute \code{type} that can take the values \code{linear} or \code{log} determines whether to draw the values logarithmically or linearly.  For example:
\begin{myXmlLst}{The \code{UniformRange} element}{lst:uniformRange}
    <uniformRange id="current" start="0.0" end="10.0" numberOfPoints="100" type="linear" /> 
\end{myXmlLst}

\paragraph{\element{VectorRange}}
\label{class:vectorRange}
A \element{VectorRange} describes a collection of real values. For example:
\begin{myXmlLst}{The \code{VectorRange} element}{lst:vectorRange}
    <vectorRange id="current"> 
        <value> 1 </value> 
        <value> 4 </value> 
        <value> 10 </value> 
    </vectorRange> 
\end{myXmlLst}

\paragraph{\element{FunctionalRange}}
\label{class:functionalRange}
A \element{FunctionalRange} constructs a range through evaluations that determine the next value. In this it is quite similar to the \hyperref[class:computeChange]{ComputeChange} element. It consists of a required attribute \code{index}, and the two elements \element{listOfVariables} and \element{function}. 

The attribute \code{index} is used to specify the \code{id} of another Range. This makes it possible for the \element{FunctionalRange} to be evaluated at different points as specified by that range. 

In the \element{listOfVariables}, analog to the \hyperref[class:computeChange]{ComputeChange} class,  additional symbols are defined from existing model references so that they can be later used in the function expression. 

The \element{function} encompasses the mathematical expression that is used to compute the values for the functional range at each of the points specified by the range referenced through the \code{index} attribute. 

For example:

\begin{myXmlLst}{An example of a \code{FunctionalRange} where a parameter \code{w} of model \code{model2} is multiplied with \code{index} each time it is called. }{lst:functionalRange}
    <functionalRange id="current" index="index"> 
      <listOfVariables> 
         <variable id="w" name="current parameter value"   
				                  modelReference="model2"
                          target="/sbml/model/listOfParameters/parameter[@id='w']" /> 
      </listOfVariables> 
      <function>
        <math xmlns="http://www.w3.org/1998/Math/MathML"> 
           <apply>
           <times/>
           <ci> w </ci> 
           <ci> index </ci> 
           </apply>
        </math>  
      </function>
    </functionalRange> 
\end{myXmlLst}

Here another example of using the values in a piecewise expression: 

\begin{myXmlLst}{A \code{FunctionalRange} element that returns \code{8} if 
  \code{index} is smaller than \code{1}, \code{0.1} if index is between 
	\code{4} and \code{6} and returns \code{8} otherwise.}{lst:functionalRange2}
        <uniformRange id="index" start="0" end="10" numberOfPoints="100" />
        <functionalRange id="current" index="index">
          <function>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <piecewise>
                <piece>
                  <cn> 8 </cn>
                  <apply>
                    <lt />
                    <ci> index </ci>
                    <cn> 1 </cn>
                  </apply>
                </piece>
                <piece>
                  <cn> 0.1 </cn>
                  <apply>
                    <and />
                    <apply>
                      <geq />
                      <ci> index </ci>
                      <cn> 4 </cn>
                    </apply>
                    <apply>
                      <lt />
                      <ci> index </ci>
                      <cn> 6 </cn>
                    </apply>
                  </apply>
                </piece>
                <otherwise>
                  <cn> 8 </cn>
                </otherwise>
              </piecewise>
            </math>
          </function>
        </functionalRange>
\end{myXmlLst}



\subsubsection{ The \element{listOfChanges}}
\label{class:changes}
\label{class:setValue}

The \element{listOfChanges} element, when present, has to contain one or more \element{setValue} elements. These elements allow to pre-condition the model that will be used for the next execution of the repeated task. 

A \element{setValue} element inherits from the SED-ML \hyperref[class:variable]{variable} class, which allows it to refer to a model element either directly using the attributes \code{modelReference} and \code{target}, or even implicit model elements using the \code{symbol} attribute. \element{setValue} has one additional atribute \code{range} an for refering to the range whose values the specified parameter will take. It also contains a child \element{math} that contains the expression for the value to set. When the expression contains a \code{ci} element that contains the value specified in the \code{range} attribute, the value of the refered range is to be inserted. 

\begin{myXmlLst}{A \code{setValue} element setting \code{w} to the values of the range with id \code{current}.}{lst:setValue}

  <listOfChanges>
    <setValue target="/sbml/model/listOfParameters/parameter[@id='w']" range="current" modelReference="model1" > 
     <math xmlns="http://www.w3.org/1998/Math/MathML"> 
         <ci> current </ci> 
     </math> 
    </setValue> 
  </listOfChanges>
\end{myXmlLst}


\subsubsection{ The \element{listOfSubTasks}}
\label{class:subTasks}
The \element{listOfSubTasks} contains one or more \element{subTask} elements that specify what simulations are to be performed by the \element{RepeatedTask}. All \element{subTask}s have to be carried out sequentially. The \code{subTask} itself has one required attribute \code{task} that references the \code{id} of another task defined in the \code{listOfTasks}. The subtasks in the list are un-ordered.  In order to prescribe an order explicitly the \code{order} attribute on the \code{subTask} is to be used. In order to establish that one subtask should be carried out before another its \code{order} attribute has to have a lower number(c.f. Listing~\ref{lst:subTask}).  

\begin{myXmlLst}{The \code{subTask} element. In the example above the task \code{task2} has to be carried out before \code{task1}.}{lst:subTask}
  <listOfSubTasks>
    <subTask task="task1" order="2"/> 
    <subTask task="task2" order="1"/> 
  </listOfSubTasks>
\end{myXmlLst}

 


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../sed-ml-L1V2"
%%% End: 