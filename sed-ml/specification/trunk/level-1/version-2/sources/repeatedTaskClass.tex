 \subsection{\element{Repeated Task}}
\label{class:repeatedTask}

The \concept{repeatedTask} class provides a generic looping construct, allowing complex tasks to be represented by composing separate steps.
It performs a specified task (or sequence of tasks) multiple times (where the exact number is specified through a \hyperref[class:range]{range} construct), while allowing specific quantities in the model to be altered at each iteration (as defined in the \hyperref[class:changes]{listOfChanges}).

The \concept{RepeatedTask} inherits from \concept{AbstractTask}.
Additionally it has two required attributes \hyperref[sec:rangeAttribute]{range} and \hyperref[sec:resetModel]{resetModel} as well as child elements \hyperref[class:ranges]{listOfRanges}, \hyperref[class:changes]{listOfChanges} and \hyperref[class:subTasks]{listOfSubTasks}.

% TODO: Somewhere, talk about what happens if you have no subTasks but instead a simulationReference.

%
\sedfig[width=.90\textwidth]{repeatedTaskClass}{The SED-ML RepeatedTask class}{fig:sedTask}
%

% TODO: Add tables for the various child elements?

\tabtext{repeatedTask}{repeatedTask}
%
\begin{table}[ht]
\center
\begin{tabular}{|l|l|}
\hline
\textbf{\attribute} & \textbf{\desc}\\
\hline
metaid$^{o}$ & \refpage{sec:metaID}\\
id & \refpage{sec:id} \\
name$^{o}$ & \refpage{sec:name}\\
\hline
range & \refpage{sec:rangeAttribute}\\
resetModel & \refpage{sec:resetModel}\\
\hline
\hline
\textbf{\subelements} & \textbf{\desc}\\
\hline
notes$^{o}$ & \refpage{class:notes}\\
annotation$^{o}$ & \refpage{class:annotation}\\
\hline
listOfRanges$^{o}$ & \refpage{class:ranges}\\
listOfChanges$^{o}$ & \refpage{class:changes}\\
listOfSubTasks$^{o}$ & \refpage{class:subTasks}\\
\hline
\hline
\end{tabular}
\caption{\tabcap{repeatedTask}}
\label{tab:repeatedTask}
\end{table}
%

% TODO: other tables don't mention the listOf* elements, but instead describe what's contained inside them.
% TODO: should all the listOf* be optional or required?  I think you'd always need at least one range, but there are cases where the others aren't needed.  For other cases in the L1V1 schema we allow to omit the listOf container if it has no children.

% TODO: inheriting or defining of modelReference and simulationReference, and explaining how these are to be interpreted.

% TODO: make sure all examples are consistent in referring to ranges etc.

\lsttext{repeatedTask}{repeatedTask}

%
\begin{myXmlLst}{The \code{repeatedTask} element}{lst:repeatedTask}
<task id="task1" modelReference="model1" simulationReference="simulation1" />

<repeatedTask id="task3" resetModel="false" range="current"
    xmlns:s='http://www.sbml.org/sbml/level3/version1/core'>
  <listOfRanges>
    <vectorRange id="current"> 
        <value> 1 </value> 
        <value> 4 </value> 
        <value> 10 </value> 
    </vectorRange> 
  </listOfRanges>
  <listOfChanges>
     <setValue target="/s:sbml/s:model/s:listOfParameters/s:parameter[@id='w']" modelReference="model1">
       <listOfVariables> 
         <variable id="val" name="current range value" target="#current" /> 
       </listOfVariables> 
       <math xmlns="http://www.w3.org/1998/Math/MathML"> 
         <ci> val </ci> 
       </math> 
     </setValue> 
  </listOfChanges>
  <listOfSubTasks>
    <subTask task="task1" />
  </listOfSubTasks>
</repeatedTask>
\end{myXmlLst}
%
In the example, \code{task1} is repeated three times, each time with a different value for a model parameter \code{w}. 


\subsubsection{The \element{range} attribute}
\label{sec:rangeAttribute}
The \element{repeatedTask} class has a required attribute \element{range} of type \code{SId}.
It specifies which \hyperref[class:range]{range} defined in the \element{listOfRanges} this repeated task iterates over.
Listing~\ref{lst:repeatedTask} shows an example of a \element{repeatedTask} iterating over a single range comprising the values: \code{1}, \code{4} and \code{10}.
If there are multiple ranges in the \element{listOfRanges}, then only the \concept{master range} identified by this attribute determines how many iterations there will be in the \element{repeatedTask}.
All other ranges must allow for at least as many iterations as the master range, and will be moved through in lock-step; their values can be used in \hyperref[class:setValue]{setValue} constructs.


\subsubsection{The \element{resetModel} attribute}
\label{sec:resetModel}
The \element{repeatedTask} class has a required attribute \element{resetModel} of type \code{boolean}. It specifies whether the model should be reset to the initial state before processing an iteration of the defined \hyperref[class:subTasks]{subTasks}. Here initial state refers to the state of the model as given in the \element{listOfModels}.  In the example in  Listing~\ref{lst:repeatedTask} the repeated task is not to be reset, so \code{task1} is carried out, another change is being made, then \code{task1} continues from there, another change is applied, and \code{task1} is carried out a last time.
% TODO: Consider if reset should instead be to the model state at start of task execution?
% This is only relevant if you have a repeatedTask as a (non-first) subTask of another repeatedTask.
% We discussed whether this would be better handled by a future extension that allows you to define a model that's the result of executing a task.
% This supports some common cases, but doesn't easily handle when you have many possible different starting states (e.g. when the first subTask gives you a different starting point each time round the outer repeatedTask).

\subsubsection{The \element{listOfRanges}}
\label{class:ranges}
Ranges represent the iterative element of the nested simulation experiment that provides the collection of values to iterate over. In order to be able to refer to the current value of a range element, an \code{id} attribute is added. When the value of the \code{id} attribute is used in a \element{listOfVariables} within the repeated task class its value is to be replaced with the current value of the range.

There are three different range types: 

\paragraph{\element{UniformRange}}
\label{class:uniformRange}
The \element{UniformRange} is quite similar to what is used in the \hyperref[class:uniformTimeCourse]{UniformTimeCourse} simulation class. This range is defined through four attributes: \code{start}, the start value; \code{end}, the end value and \code{numberOfPoints} that contains the number of points the range contains. A fourth attribute \code{type} that can take the values \code{linear} or \code{log} determines whether to draw the values logarithmically (with a base of $10$) or linearly.  For example:
\begin{myXmlLst}{The \code{UniformRange} element}{lst:uniformRange}
    <uniformRange id="current" start="0.0" end="10.0" numberOfPoints="100" type="linear" /> 
\end{myXmlLst}
As for \hyperref[class:uniformTimeCourse]{UniformTimeCourse}, this range will actually produce 101 values uniformly spaced on the interval $[0, 10]$, in ascending order.

The following logarithmic example generates the three values \code{1}, \code{10} and \code{100}.
\begin{myXmlList}{The \code{UniformRange} element with a logarithmic range.}{lst:uniformRangeLog}
    <uniformRange id="current" start="1.0" end="100.0" numberOfPoints="2" type="log" />
\end{myXmlList}

\paragraph{\element{VectorRange}}
\label{class:vectorRange}
A \element{VectorRange} describes an ordered collection of real values. For example:
\begin{myXmlLst}{The \code{VectorRange} element}{lst:vectorRange}
    <vectorRange id="current"> 
        <value> 1 </value> 
        <value> 4 </value> 
        <value> 10 </value> 
    </vectorRange> 
\end{myXmlLst}

\paragraph{\element{FunctionalRange}}
\label{class:functionalRange}
A \element{FunctionalRange} constructs a range through calculations that determine the next value based on the value(s) of other range(s) or model variables.
In this it is quite similar to the \hyperref[class:computeChange]{ComputeChange} element.
It consists of a required attribute \code{index}, and the two elements \element{listOfVariables} and \element{function}.
% TODO: Change index to range for consistency? (c.f. http://sourceforge.net/mailarchive/message.php?msg_id=29865720)
% TODO: Could index not be required, and instead other ranges referenced as done in setValue (c.f. above email too)?

The required attribute \code{index} is used to specify the \code{id} of another \concept{Range}, which determines how many points are contained in this range.
Values from the referenced range may also be used within the function defining this \element{FunctionalRange}.

In the \element{listOfVariables}, analog to the \hyperref[class:computeChange]{ComputeChange} class,  additional symbols are defined from existing model references so that they can be later used in the function expression. 

The \element{function} encompasses the mathematical expression that is used to compute the values for the functional range at each of the points specified by the range referenced through the \code{index} attribute. 

For example:

\begin{myXmlLst}{An example of a \code{FunctionalRange} where a parameter \code{w} of model \code{model2} is multiplied with \code{index} each time it is called. }{lst:functionalRange}
  <functionalRange id="current" index="index"
      xmlns:s='http://www.sbml.org/sbml/level3/version1/core'>
    <listOfVariables>
      <variable id="w" name="current parameter value" modelReference="model2"
          target="/s:sbml/s:model/s:listOfParameters/s:parameter[@id='w']" />
    </listOfVariables>
    <function>
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <apply>
          <times/>
          <ci> w </ci>
          <ci> index </ci>
        </apply>
      </math>
    </function>
  </functionalRange>
\end{myXmlLst}

Here another example of using the values in a piecewise expression: 

\begin{myXmlLst}{A \code{FunctionalRange} element that returns \code{8} if 
  \code{index} is smaller than \code{1}, \code{0.1} if index is between 
	\code{4} and \code{6} and returns \code{8} otherwise.}{lst:functionalRange2}
        <uniformRange id="index" start="0" end="10" numberOfPoints="100" />
        <functionalRange id="current" index="index">
          <function>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <piecewise>
                <piece>
                  <cn> 8 </cn>
                  <apply>
                    <lt />
                    <ci> index </ci>
                    <cn> 1 </cn>
                  </apply>
                </piece>
                <piece>
                  <cn> 0.1 </cn>
                  <apply>
                    <and />
                    <apply>
                      <geq />
                      <ci> index </ci>
                      <cn> 4 </cn>
                    </apply>
                    <apply>
                      <lt />
                      <ci> index </ci>
                      <cn> 6 </cn>
                    </apply>
                  </apply>
                </piece>
                <otherwise>
                  <cn> 8 </cn>
                </otherwise>
              </piecewise>
            </math>
          </function>
        </functionalRange>
\end{myXmlLst}



\subsubsection{The \element{listOfChanges}}
\label{class:changes}
\label{class:setValue}

The \element{listOfChanges} element, when present, contains one or more \element{setValue} elements.
These elements allow to modify values in the model prior to the next execution of the repeated task.

A \element{setValue} element inherits from the SED-ML \hyperref[class:variable]{variable} class, which allows it to refer to a model element directly using the attributes \code{modelReference} and \code{target}, or to an implicit model element using the \code{symbol} attribute.
\element{setValue} has one additional atribute \code{range} for refering to the range whose values will be used to compute a value for the specified model element.
It also contains a child \element{math} that contains the expression computing the value.
When the expression contains a \code{ci} element that contains the value specified in the \code{range} attribute, the value of the refered range is to be inserted.

\begin{myXmlLst}{A \code{setValue} element setting \code{w} to the values of the range with id \code{current}.}{lst:setValue}
  <listOfChanges>
    <setValue target="/s:sbml/s:model/s:listOfParameters/s:parameter[@id='w']"
              range="current" modelReference="model1">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <ci> current </ci>
      </math>
    </setValue>
  </listOfChanges>
\end{myXmlLst}

\subsubsection{The \element{listOfSubTasks}}
\label{class:subTasks}
The \element{listOfSubTasks} contains one or more \element{subTask} elements that specify what simulations are to be performed by the \element{RepeatedTask}. All \element{subTask}s have to be carried out sequentially. The \code{subTask} itself has one required attribute \code{task} that references the \code{id} of another task defined in the \code{listOfTasks}. The subtasks in the list are un-ordered.  In order to prescribe an order explicitly the \code{order} attribute on the \code{subTask} is to be used. In order to establish that one subtask should be carried out before another its \code{order} attribute has to have a lower number(c.f. Listing~\ref{lst:subTask}).
% TODO: Order subTasks by order in the XML.
% TODO: Be explicit about what it means to have multiple subTasks, whether resets happen, how results arise from these, etc.
% I think we'd agreed that you simply run the second task from the model state at the end of the first task, and concatenate the results.

\begin{myXmlLst}{The \code{subTask} element. In the example above the task \code{task2} has to be carried out before \code{task1}.}{lst:subTask}
  <listOfSubTasks>
    <subTask task="task1" order="2"/> 
    <subTask task="task2" order="1"/> 
  </listOfSubTasks>
\end{myXmlLst}

 


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../sed-ml-L1V2"
%%% End: 